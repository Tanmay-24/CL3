import tensorflow as tf
from tensorflow.keras.applications import vgg19
from tensorflow.keras.preprocessing import image as keras_image
import numpy as np
import matplotlib.pyplot as plt

# Load and preprocess the images
def load_image(img_path):
    img = keras_image.load_img(img_path, target_size=(224, 224))
    img = keras_image.img_to_array(img)
    img = np.expand_dims(img, axis=0)
    return vgg19.preprocess_input(img)

# Deprocess the image for display
def deprocess_image(img):
    img = img.reshape((224, 224, 3))
    img = [123.68, 116.779, 103.939] * img  # Corrected mean values
    img = np.clip(img[:, :, ::-1], 0, 255).astype('uint8')
    return img

# Load images
content_image = load_image(r'C:\Users\WOMIT\Pictures\Xawes Pictures\Q65688162.JPG')  # Added raw string
style_image = load_image(r'C:\Users\WOMIT\Pictures\Camera Roll\WHN_20220121_10_34_30_Pro.jpg')  # Added raw string

# Create a generated image
generated_image = tf.Variable(content_image, dtype=tf.float32)

# Load VGG19 model
model = vgg19.VGG19(weights='imagenet', include_top=False)
model.trainable = False

# Define layers for content and style
content_layer = 'block5_conv2'  # Corrected layer name
style_layers = ['block1_conv1', 'block2_conv1', 'block3_conv1', 'block4_conv1', 'block5_conv1']  # Corrected layer names

# Get model outputs
outputs = [model.get_layer(name).output for name in style_layers + [content_layer]]
model = tf.keras.Model([model.input], outputs)

# Define loss functions
def compute_loss():
    content_loss = tf.reduce_mean(tf.square(model(generated_image)[-1] - model(content_image)[-1]))
    
    style_loss = sum([tf.reduce_mean(tf.square(model(generated_image)[i] - model(style_image)[i])) for i in range(len(style_layers))])
    
    return content_loss + 1e-2 * style_loss  # Weight for style loss

# Optimize the generated image
optimizer = tf.keras.optimizers.Adam(learning_rate=0.02)
for i in range(100):  # Number of iterations
    with tf.GradientTape() as tape:
        loss = compute_loss()
    grads = tape.gradient(loss, generated_image)
    optimizer.apply_gradients([(grads, generated_image)])
    if i % 10 == 0:
        print(f"Iteration {i}, loss: {loss.numpy()}")

# Display the generated image
plt.imshow(deprocess_image(generated_image.numpy()))
plt.axis('off')
plt.show()
